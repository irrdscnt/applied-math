import numpy as np
# Матрица коэффициентов A
A = np.array([[6.0, 3.0, 0.0, 0.0],
              [1.0, -2.0, 0.3, 0.0],
              [0.0, 2.0, 3.0,-1.0],
              [0.0, 0.0, -1.0, 4.0]])

# Вектор правой части b
b = np.array([7.0, 4.3, 3.0, 8.0])
# # Матрица коэффициентов A
# A = np.array([[-3.0, 1.2, 0.0, 0.0, 0.0],
#               [2.0, -5.0, 1.0, 0.0, 0.0],
#               [0.0, 1.1, 4.0, -1.0, 0.0],
#               [0.0, 0.0, 5.0, 9.0, 2.0],
#               [0.0, 0.0, 0.0, -2.0, 6.5]])

# # Вектор правой части b
# b = np.array([-1.7, -2.0, 3.0, 11.0, 2.0])

# Размерность системы
n = len(b)

# Инициализация массивов для хранения коэффициентов прогона и обратного хода
alpha = np.zeros(n - 1)
beta = np.zeros(n)

# Прямой ход (нахождение alpha и beta)
alpha[0] = -A[0, 1] / A[0, 0]
beta[0] = b[0] / A[0, 0]

for i in range(1, n - 1):
    denom = A[i, i] + A[i, i - 1] * alpha[i - 1]
    alpha[i] = -A[i, i + 1] / denom
    beta[i] = (b[i] - A[i, i - 1] * beta[i - 1]) / denom

# Обратный ход (нахождение x)
x = np.zeros(n)
x[n - 1] = (b[n - 1] - A[n - 1, n - 2] * beta[n - 2]) / (A[n - 1, n - 1] + A[n - 1, n - 2] * alpha[n - 2])

for i in range(n - 2, -1, -1):
    x[i] = alpha[i] * x[i + 1] + beta[i]

# Вывод решения с заданной точностью
tolerance = 0.001
# solution = np.round(x, 4)

print("Решение системы методом прогонки:")
print(x)




